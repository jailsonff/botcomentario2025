import time
import random
import os
import pyperclip
import threading
from PyQt5.QtCore import QThread, pyqtSignal
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException, StaleElementReferenceException
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains

class AutomacaoComentariosWorker(QThread):
    """
    Worker especializado para executar coment√°rios automatizados em posts do Instagram usando perfis do Dolphin Anty.
    """
    # Sinais: perfil, a√ß√£o, sucesso, mensagem
    acao_concluida = pyqtSignal(str, str, bool, str)
    progresso_atualizado = pyqtSignal(int, int)  # a√ß√µes conclu√≠das, total de a√ß√µes
    status_update = pyqtSignal(str)
    automacao_concluida = pyqtSignal()

    def __init__(self, dolphin_manager, post_url, perfis, total_acoes, perfis_simultaneos, 
                 tempo_entre_acoes, texto_comentario="", parent=None, manter_navegador_aberto=False):
        super().__init__(parent)
        self.dolphin_manager = dolphin_manager
        self.post_url = post_url
        self.perfis = perfis  # Lista de nomes de usu√°rio dos perfis
        self.total_acoes = total_acoes
        self.perfis_simultaneos = perfis_simultaneos
        self.tempo_entre_acoes = tempo_entre_acoes
        self.manter_navegador_aberto = manter_navegador_aberto
        
        # Tratar o texto_comentario como uma lista de coment√°rios
        if texto_comentario:
            # Dividir o texto em linhas e filtrar linhas vazias
            self.lista_comentarios = [linha.strip() for linha in texto_comentario.split('\n') if linha.strip()]
        else:
            self.lista_comentarios = []
        self._stop_flag = False
        self.acoes_concluidas = 0
        self.workers_ativos = {}  # Armazena os drivers ativos por perfil

    def stop(self):
        """Para a execu√ß√£o da automa√ß√£o."""
        self._stop_flag = True
        self.workers_ativos.clear()

    def run(self):
        """Executa a automa√ß√£o de coment√°rios nos perfis."""
        if not self.perfis or not self.post_url:
            self.status_update.emit("‚ùå Erro: URL do post ou lista de perfis vazia.")
            self.automacao_concluida.emit()
            return

        # Verifica se h√° coment√°rios dispon√≠veis
        if not self.lista_comentarios:
            self.status_update.emit("‚ùå Erro: Nenhum coment√°rio definido.")
            self.automacao_concluida.emit()
            return

        # Verifica se o n√∫mero de a√ß√µes √© maior que o n√∫mero de perfis dispon√≠veis
        if self.total_acoes > len(self.perfis):
            self.status_update.emit(f"‚ö†Ô∏è Aviso: O n√∫mero de a√ß√µes ({self.total_acoes}) √© maior que o n√∫mero de perfis dispon√≠veis ({len(self.perfis)}). Alguns perfis ser√£o usados mais de uma vez.")

        # Embaralha a lista de perfis para usar em ordem aleat√≥ria
        perfis_disponiveis = self.perfis.copy()
        random.shuffle(perfis_disponiveis)

        # Inicia o loop de automa√ß√£o
        self.acoes_concluidas = 0
        self.progresso_atualizado.emit(self.acoes_concluidas, self.total_acoes)
        
        # Criar um lock para acesso thread-safe √† vari√°vel acoes_concluidas
        self.acoes_lock = threading.Lock()
        
        # Criar uma lista para controlar os perfis j√° usados
        self.perfis_em_execucao = []
        
        while self.acoes_concluidas < self.total_acoes and not self._stop_flag:
            # Verifica quantos workers est√£o ativos no momento
            workers_ativos_count = len(self.workers_ativos)
            
            # Se j√° temos o m√°ximo de workers ativos, aguarda
            if workers_ativos_count >= self.perfis_simultaneos:
                time.sleep(1)
                continue
            
            # Verificar quantas a√ß√µes j√° foram iniciadas (em execu√ß√£o + conclu√≠das)
            with self.acoes_lock:
                acoes_em_andamento = len(self.perfis_em_execucao)
                acoes_totais_iniciadas = acoes_em_andamento + self.acoes_concluidas
                
                # Se j√° iniciamos todas as a√ß√µes necess√°rias, apenas aguarda a conclus√£o
                if acoes_totais_iniciadas >= self.total_acoes:
                    time.sleep(1)
                    continue
            
            # Selecionar pr√≥ximo perfil dispon√≠vel
            perfil_escolhido = None
            for perfil in perfis_disponiveis:
                if perfil not in self.perfis_em_execucao and perfil not in self.workers_ativos:
                    perfil_escolhido = perfil
                    break
            
            # Se n√£o encontrou perfil dispon√≠vel, tentar reutilizar um perfil
            if not perfil_escolhido and self.total_acoes > len(self.perfis):
                # Verificar quais perfis j√° foram usados mas n√£o est√£o ativos no momento
                perfis_ja_usados = [p for p in self.perfis if p not in self.perfis_em_execucao and p not in self.workers_ativos]
                if perfis_ja_usados:
                    perfil_escolhido = random.choice(perfis_ja_usados)
            
            # Se ainda n√£o encontrou perfil, aguardar
            if not perfil_escolhido:
                time.sleep(1)
                continue
            
            # Adicionar perfil √† lista de perfis em execu√ß√£o
            self.perfis_em_execucao.append(perfil_escolhido)
            
            # Iniciar thread para executar a a√ß√£o neste perfil
            self.status_update.emit(f"üöÄ Iniciando a√ß√£o com perfil '{perfil_escolhido}'")
            threading.Thread(target=self._executar_acao_perfil, args=(perfil_escolhido,)).start()
            
            # Aguardar intervalo entre a√ß√µes
            intervalo = random.uniform(self.tempo_entre_acoes * 0.8, self.tempo_entre_acoes * 1.2)  # Varia√ß√£o de ¬±20%
            self.status_update.emit(f"‚è±Ô∏è Aguardando {intervalo:.1f} segundos antes da pr√≥xima a√ß√£o...")
            time.sleep(intervalo)
        
        # Aguardar todos os workers conclu√≠rem
        while self.workers_ativos and not self._stop_flag:
            self.status_update.emit(f"‚åõ Aguardando {len(self.workers_ativos)} workers conclu√≠rem...")
            time.sleep(2)
        
        # Emitir sinal de conclus√£o
        self.status_update.emit(f"‚úÖ Automa√ß√£o conclu√≠da! {self.acoes_concluidas} coment√°rios realizados.")
        self.automacao_concluida.emit()

    def _executar_acao_perfil(self, username):
        """Executa a a√ß√£o para um perfil espec√≠fico."""
        if self._stop_flag:
            if username in self.perfis_em_execucao:
                self.perfis_em_execucao.remove(username)
            return
        
        # Tentar obter um coment√°rio aleat√≥rio
        if not self.lista_comentarios:
            self.status_update.emit(f"‚ùå Erro: Lista de coment√°rios vazia para '{username}'.")
            if username in self.perfis_em_execucao:
                self.perfis_em_execucao.remove(username)
            return
        
        comentario = random.choice(self.lista_comentarios)
        
        self.status_update.emit(f"üîÑ Iniciando navegador para '{username}'...")
        
        # Iniciar navegador e abrir post
        success, message = self.dolphin_manager.launch_profile_instagram(username, go_to_instagram_home=False)
        
        if not success:
            self.status_update.emit(f"‚ùå Erro ao abrir navegador para '{username}': {message}")
            if username in self.perfis_em_execucao:
                self.perfis_em_execucao.remove(username)
            return
        
        driver = self.dolphin_manager.get_profile_driver(username)
        if not driver:
            self.status_update.emit(f"‚ùå Erro: Driver n√£o encontrado para '{username}'.")
            if username in self.perfis_em_execucao:
                self.perfis_em_execucao.remove(username)
            return
        
        # Adicionar √† lista de workers ativos
        self.workers_ativos[username] = driver
        
        # Navegar para o post
        try:
            self.status_update.emit(f"üåê Navegando para URL do post ({username})...")
            driver.get(self.post_url)
            
            # Aguardar um tempo m√≠nimo para carregamento inicial
            time.sleep(2)
            
            # Se for um perfil espec√≠fico como gabrielamartinsrt, tentar comentar imediatamente
            if "gabrielamartinsrt" in self.post_url or "iniciar_rapido" in str(username).lower():
                self.status_update.emit(f"‚ö° Perfil espec√≠fico detectado. Iniciando coment√°rio imediato para '{username}'...")
                success = self._comentar_post(driver, username, comentario, self.acoes_concluidas)
                if success:
                    self.acoes_concluidas += 1
                    self.progresso_atualizado.emit(self.acoes_concluidas, self.total_acoes)
                    self.status_update.emit(f"‚úÖ Coment√°rio enviado com sucesso para '{username}'!")
                if username in self.perfis_em_execucao:
                    self.perfis_em_execucao.remove(username)
                if username in self.workers_ativos:
                    del self.workers_ativos[username]
                if not self.manter_navegador_aberto:
                    driver.quit()
                return
            
            # Para outros perfis, continuar com o fluxo normal
            # Aguardar carregamento da p√°gina
            self._aguardar_carregamento_pagina(driver, username)
            
            # Aguardar um tempo para garantir que a p√°gina esteja totalmente carregada (crucial para m√∫ltiplos perfis)
            time.sleep(3)
            
            # IMPORTANTE: Para perfis m√∫ltiplos, precisamos dar foco para este navegador
            try:
                driver.execute_script("window.focus();")
                time.sleep(1)
                # Mover mouse para o centro da tela para ativa√ß√£o
                action = ActionChains(driver)
                action.move_by_offset(0, 0).click().perform()
                self.status_update.emit(f"üëÅÔ∏è Dando foco ao navegador de '{username}'...")
                time.sleep(0.5)
            except Exception as e:
                self.status_update.emit(f"‚ö†Ô∏è Erro ao ativar navegador: {str(e)}")
            
            # Verificar se est√° logado
            if not self.dolphin_manager.is_logged_in(driver):
                self.status_update.emit(f"üîë Perfil '{username}' n√£o est√° logado. Tentando login autom√°tico...")
                login_success, login_message = self.dolphin_manager.attempt_login_instagram(
                    driver, username, "sua_senha_aqui"
                )
                
                if not login_success:
                    self.status_update.emit(f"‚ùå Falha no login para '{username}': {login_message}")
                    driver.quit()
                    if username in self.workers_ativos:
                        del self.workers_ativos[username]
                    if username in self.perfis_em_execucao:
                        self.perfis_em_execucao.remove(username)
                    return
                
                # Ap√≥s login bem-sucedido, navegar novamente para o post
                driver.get(self.post_url)
                self._aguardar_carregamento_pagina(driver, username)
            
            # Lista para rastrear a√ß√µes realizadas
            acoes_realizadas = []
            
            # Realizar coment√°rio
            self.status_update.emit(f"üí¨ Tentando comentar com perfil '{username}'...")
            comentario_realizado = self._comentar_post(driver, username, comentario, acoes_realizadas)
            
            if not comentario_realizado:
                self.status_update.emit(f"‚ùå Falha ao comentar com perfil '{username}'.")
                driver.quit()
                if username in self.workers_ativos:
                    del self.workers_ativos[username]
                if username in self.perfis_em_execucao:
                    self.perfis_em_execucao.remove(username)
                return
            
        except Exception as e:
            self.status_update.emit(f"‚ö†Ô∏è Erro ao aguardar carregamento: {str(e)}")
            self.status_update.emit(f"‚ùå Erro durante execu√ß√£o para '{username}': {str(e)}")
            driver.quit()
            if username in self.workers_ativos:
                del self.workers_ativos[username]
            if username in self.perfis_em_execucao:
                self.perfis_em_execucao.remove(username)
            return

    def _aguardar_carregamento_pagina(self, driver, username):
        """Aguarda o carregamento da p√°gina."""
        try:
            self.status_update.emit(f"‚è≥ Aguardando carregamento da p√°gina para '{username}'...")
            wait = WebDriverWait(driver, 30)
            wait.until(EC.presence_of_element_located((By.TAG_NAME, "article")))
            
            # Reduzido o tempo de espera ap√≥s carregar o artigo para agilizar o coment√°rio
            time.sleep(2)  # Tempo suficiente para garantir que podemos interagir com a p√°gina
            
            # Procurar explicitamente pelo campo de coment√°rio para garantir que est√° carregado
            seletores_campo_comentario = [
                "//form[contains(@class, 'comment')]//textarea",
                "//textarea[contains(@placeholder, 'coment')]",
                "//textarea[contains(@aria-label, 'comment')]",
                "//*[@role='textbox' and contains(@aria-label, 'coment')]",
                "//*[@placeholder='Adicione um coment√°rio...']",
                "//*[@placeholder='Add a comment‚Ä¶']"
            ]
            
            for seletor in seletores_campo_comentario:
                try:
                    wait.until(EC.presence_of_element_located((By.XPATH, seletor)))
                    self.status_update.emit(f"‚úÖ Campo de coment√°rio encontrado e pronto para '{username}'")
                    return  # Encontrou o campo, podemos continuar
                except:
                    continue
            
            # Se n√£o encontrou o campo, tentar rolar a p√°gina
            driver.execute_script("window.scrollTo(0, document.body.scrollHeight/2);")
            time.sleep(1)
        except Exception as e:
            self.status_update.emit(f"‚ö†Ô∏è Erro ao aguardar carregamento: {str(e)}")

def _aguardar_carregamento_pagina(self, driver, username):
        driver.switch_to.window(driver.current_window_handle)
        driver.execute_script("window.focus();")
    except Exception as e:
        self.status_update.emit(f"‚ö†Ô∏è Erro ao ativar navegador: {str(e)}")
    # Loop de tentativas para comentar
    for tentativa in range(1, max_tentativas + 1):
        self.status_update.emit(f"üí¨ Tentativa {tentativa}/{max_tentativas} de comentar com '{username}'...")
        # Identificar o campo de coment√°rio com estrat√©gia mais agressiva
        seletores_campo_comentario = [
            # Seletores espec√≠ficos do Instagram
            "//form[contains(@class, 'comment')]//textarea",
            "//textarea[contains(@placeholder, 'coment')]",
            "//textarea[contains(@aria-label, 'comment')]",
            "//textarea[contains(@aria-label, 'coment')]",
            "//*[@role='textbox' and contains(@aria-label, 'coment')]",
            "//*[@role='textbox' and contains(@aria-label, 'comment')]",
            "//*[@role='textbox']",  # Seletor mais gen√©rico
            "//*[@placeholder='Adicione um coment√°rio...']",
            "//*[@placeholder='Add a comment‚Ä¶']",
            "//span[text()='Add a comment‚Ä¶']/parent::*/parent::*//*[@role='textbox']",
            "//span[text()='Adicione um coment√°rio...']/parent::*/parent::*//*[@role='textbox']",
            # Seletores para caminhos XPath completos observados em diferentes vers√µes do Instagram
            "//section/div/div[2]/div/div/div/div[1]/div/div[2]/div/div/div/div[2]/div/div/div[4]/div/div/div/div/div[2]/div/div/div/div/div/div/textarea",
            "//section/div/div/div/div/div/div[1]/div/div[2]/div/div/div/div[2]/div/div/div[2]/div/div/div/div/div[2]/div/div/div/div/div/div/textarea",
            # Seletores mais gen√©ricos como √∫ltimo recurso
            "//form//textarea",  # Qualquer textarea dentro de um form
            "//section//textarea",  # Qualquer textarea dentro de section
            "//div[@role='dialog']//textarea",  # Para posts abertos em modal
            "//textarea"  # √öltimo recurso: qualquer textarea na p√°gina
        ]
        campo_comentario = None # Resetar campo para cada tentativa
        # Tentar encontrar o campo de coment√°rio
        try:
            wait = WebDriverWait(driver, 7) # Tempo de espera reduzido para agilizar tentativas
            for seletor in seletores_campo_comentario:
                try:
                    campo_comentario = wait.until(EC.element_to_be_clickable((By.XPATH, seletor)))
                    if campo_comentario.is_displayed():
                        self.status_update.emit(f"‚úÖ Campo de coment√°rio encontrado com seletor: {seletor}")
                        break
                except:
                    continue
        except Exception as e_wait:
            self.status_update.emit(f"‚ö†Ô∏è Erro ao esperar pelo campo de coment√°rio: {str(e_wait)}")
        # Se n√£o encontrou com espera, tentar find_element (pode ser mais r√°pido se j√° estiver l√°)
        if not campo_comentario:
            for seletor in seletores_campo_comentario:
                try:
                    campo_comentario = driver.find_element(By.XPATH, seletor)
                    if campo_comentario.is_displayed():
                        self.status_update.emit(f"‚úÖ Campo de coment√°rio encontrado com seletor: {seletor}")
                        break
                except:
                    continue
        # Se ainda n√£o encontrou, tentar rolagem em diferentes posi√ß√µes
        if not campo_comentario:
            self.status_update.emit(f"‚ö†Ô∏è Campo de coment√°rio n√£o encontrado. Tentando rolagens diferentes...")
            posicoes_rolagem = [100, 300, 500, 800, -100, -300]
            for posicao in posicoes_rolagem:
                try:
                    driver.execute_script(f"window.scrollBy(0, {posicao});")
                    time.sleep(1)
                    for seletor in seletores_campo_comentario:
                        try:
                            campo_comentario = driver.find_element(By.XPATH, seletor)
                            if campo_comentario.is_displayed():
                                self.status_update.emit(f"‚úÖ Campo de coment√°rio encontrado ap√≥s rolagem {posicao}px: {seletor}")
                                break
                        except:
                            continue
                    if campo_comentario and campo_comentario.is_displayed():
                        break
                except Exception as e:
                    self.status_update.emit(f"‚ö†Ô∏è Erro ao rolar p√°gina: {str(e)}") # Esta linha agora est√° corretamente indentada
        # Verificar se o campo foi encontrado ap√≥s todas as tentativas de busca e rolagem
        if not campo_comentario:
            self.status_update.emit(f"‚ùå Campo de coment√°rio n√£o encontrado em tentativa {tentativa}")
            if tentativa < max_tentativas:
                continue # Ir para a pr√≥xima tentativa
            else:
                return False
        # Estrat√©gia 1: Clique e digita√ß√£o direta com foco garantido
        try:
            self.status_update.emit("üí¨ Campo encontrado. Tentando digitar e enviar...")
            # IMPORTANTE: Para m√∫ltiplos perfis, precisamos garantir o foco no elemento
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", campo_comentario)
            time.sleep(0.5)
            # Usar JavaScript para destacar o campo vis√≠vel
            driver.execute_script("""
                arguments[0].style.border = '2px solid red'; 
                arguments[0].style.backgroundColor = '#ffffcc';
            """, campo_comentario)
            time.sleep(0.5)
            # Limpar o campo usando JavaScript primeiro
            driver.execute_script("arguments[0].value = '';", campo_comentario)
            # Clicar usando ActionChains para maior confiabilidade
            actions = ActionChains(driver)
            actions.move_to_element(campo_comentario).click().perform()
            time.sleep(0.5)
            # Tentar digitar com diferentes m√©todos
            campo_comentario.clear()
            time.sleep(0.3)
            # M√©todo 1: Envio direto
            campo_comentario.send_keys(texto_comentario)
            time.sleep(0.5)
            # M√©todo 2: Digitar caractere por caractere
            if not campo_comentario.get_attribute("value"):
                for char in texto_comentario:
                    campo_comentario.send_keys(char)
                    time.sleep(0.05)
            time.sleep(0.5)
            sent_success = False # Flag para verificar se o coment√°rio foi enviado
            # M√©todos diversos para enviar o coment√°rio
            self.status_update.emit(f"üí¨ Tentando enviar coment√°rio por m√∫ltiplos m√©todos...")
            # M√©todo 1: Pressionar Enter diretamente no campo
            try:
                self.status_update.emit("M√©todo 1: Pressionar Enter")
                campo_comentario.send_keys(Keys.ENTER)
                time.sleep(2)
                # Verificar se o coment√°rio foi enviado checando se o campo est√° vazio
                if not campo_comentario.get_attribute("value"):
                    self.status_update.emit("‚úÖ Coment√°rio enviado com o m√©todo 1!")
                    sent_success = True
            except Exception as e:
                self.status_update.emit(f"‚ö†Ô∏è Erro no m√©todo 1: {str(e)}")
            # M√©todo 2: Procurar e clicar no bot√£o de publicar/postar
            if not sent_success:
                try:
                    self.status_update.emit("M√©todo 2: Clicar no bot√£o Publicar")
                    # Seletores para bot√µes de publicar
                    seletores_botao_publicar = [
                        "//button[contains(text(), 'Publicar')]",
                        "//button[contains(text(), 'Post')]",
                        "//button[contains(text(), 'Postar')]",
                        "//button[contains(text(), 'Comment')]",
                        "//button[contains(text(), 'Comentar')]",
                        "//form//button[@type='submit']",
                        "//div[contains(@aria-label, 'coment')]/following-sibling::*//button",
                        "//textarea/../..//button", # Bot√£o mais pr√≥ximo do textarea
                        "//section//form//button" # Qualquer bot√£o dentro de um formul√°rio em uma se√ß√£o
                    ]
                    for seletor in seletores_botao_publicar:
                        try:
                            botao = driver.find_element(By.XPATH, seletor)
                            if botao.is_displayed() and botao.is_enabled():
                                driver.execute_script("arguments[0].style.border = '2px solid green';", botao)
                                time.sleep(0.5)
                                botao.click()
                                time.sleep(2)
                                # Verificar se o coment√°rio foi enviado
                                if not campo_comentario.get_attribute("value"):
                                    self.status_update.emit(f"‚úÖ Coment√°rio enviado com o m√©todo 2 (bot√£o: {seletor})!")
                                    sent_success = True
                                    break
                        except Exception as e_btn:
                            continue
                except Exception as e:
                    self.status_update.emit(f"‚ö†Ô∏è Erro no m√©todo 2: {str(e)}")
            # M√©todo 3: Usar JavaScript para acionar eventos e submeter o formul√°rio
            if not sent_success:
                try:
                    self.status_update.emit("M√©todo 3: Acionamento via JavaScript")
                    # Tentar submeter via JavaScript - muitas possibilidades diferentes
                    scripts_js = [
                        # Acionar o evento Enter no campo
                        "arguments[0].dispatchEvent(new KeyboardEvent('keydown', {'key': 'Enter', 'code': 'Enter', 'keyCode': 13, 'which': 13, 'bubbles': true}));",
                        # Procurar o formul√°rio pai e submeter
                        "arguments[0].form.submit();",
                        # Encontrar o bot√£o mais pr√≥ximo e clicar
                        "arguments[0].closest('form').querySelector('button[type=submit]').click();",
                        # Inserir o texto via JS e acionar Enter
                        "arguments[0].value = arguments[1]; arguments[0].dispatchEvent(new Event('input', { bubbles: true })); arguments[0].dispatchEvent(new KeyboardEvent('keydown', {'key': 'Enter', 'keyCode': 13, 'which': 13, 'bubbles': true}));"
                    ]
                    for script in scripts_js:
                        try:
                            if "arguments[1]" in script:
                                driver.execute_script(script, campo_comentario, texto_comentario)
                            else:
                                driver.execute_script(script, campo_comentario)
                            time.sleep(2)
                            # Verificar se o coment√°rio foi enviado
                            if not campo_comentario.get_attribute("value"):
                                self.status_update.emit("‚úÖ Coment√°rio enviado com o m√©todo 3 (JavaScript)!")
                                sent_success = True
                                break
                        except Exception as e_js:
                            continue
                except Exception as e:
                    self.status_update.emit(f"‚ö†Ô∏è Erro no m√©todo 3: {str(e)}")
            # M√©todo 4: ActionChains para simular comportamento humano mais detalhado
            if not sent_success:
                try:
                    self.status_update.emit("M√©todo 4: ActionChains avan√ßado")
                    actions = ActionChains(driver)
                    # Clicar, digitar, pressionar Enter (sequ√™ncia mais completa)
                    actions.click(campo_comentario)
                    actions.pause(0.5)
                    actions.key_down(Keys.CONTROL).send_keys('a').key_up(Keys.CONTROL)
                    actions.pause(0.3)
                    actions.send_keys(Keys.DELETE)
                    actions.pause(0.3)
                    actions.send_keys(texto_comentario)
                    actions.pause(0.5)
                    actions.send_keys(Keys.ENTER)
                    actions.perform()
                    time.sleep(2)
                    if not campo_comentario.get_attribute("value"):
                        self.status_update.emit("‚úÖ Coment√°rio enviado com o m√©todo 4 (ActionChains)!")
                        sent_success = True
                except Exception as e:
                    self.status_update.emit(f"‚ö†Ô∏è Erro no m√©todo 4: {str(e)}")
            # Tentar enviar coment√°rio
            try:
                # M√©todo 1: Pressionar Enter usando diferentes abordagens
                # Primeiro, verificar se o texto foi inserido corretamente
                # Nota: get_attribute("value") pode n√£o funcionar em todos os elementos de texto
                campo_valor = campo_comentario.get_attribute("value")
                self.status_update.emit(f"üí¨ Texto inserido: '{campo_valor}'")
                ActionChains(driver).send_keys(Keys.ENTER).perform()
                time.sleep(1)
                # Verificar se o coment√°rio foi enviado
                if self._verificar_comentario_enviado(driver, texto_comentario):
                    self.status_update.emit(f"‚úÖ Coment√°rio verificado ap√≥s envio (m√©todo Enter).")
                    sent_success = True
            except Exception as e_enter:
                self.status_update.emit(f"‚ö†Ô∏è Erro ao tentar enviar com Enter: {str(e_enter)}")
            # M√©todo 2: Procurar bot√£o de enviar/publicar
            try:
                botoes_enviar = [
                    "//button[contains(text(), 'Publicar')]",
                    "//button[contains(text(), 'Post')]",
                    "//button[contains(@aria-label, 'Publicar')]",
                    "//button[contains(@aria-label, 'Post')]",
                    "//div[contains(text(), 'Publicar')]/parent::button",
                    "//div[contains(text(), 'Post')]/parent::button"
                ]
                for seletor_botao in botoes_enviar:
                    try:
                        botao_publicar = driver.find_element(By.XPATH, seletor_botao)
                        if botao_publicar.is_displayed() and botao_publicar.is_enabled():
                            botao_publicar.click()
                            time.sleep(2)
                            # Verificar se o coment√°rio foi enviado
                            if self._verificar_comentario_enviado(driver, texto_comentario):
                                self.status_update.emit(f"‚úÖ Coment√°rio verificado ap√≥s envio (m√©todo bot√£o).")
                                sent_success = True
                                break # Sai do loop de seletores de bot√£o
                    except Exception as e_botao:
                        self.status_update.emit(f"‚ö†Ô∏è Erro ao tentar bot√£o '{seletor_botao}': {str(e_botao)}")
                        continue
            except Exception as e_botoes_geral:
                self.status_update.emit(f"‚ö†Ô∏è Erro geral ao buscar bot√µes de publicar: {str(e_botoes_geral)}")
            # Verificar novamente se o coment√°rio foi enviado ap√≥s tentar os bot√µes
            if not sent_success and self._verificar_comentario_enviado(driver, texto_comentario):
                self.status_update.emit(f"‚úÖ Coment√°rio verificado ap√≥s envio (verifica√ß√£o final).")
                sent_success = True
            # Se o coment√°rio foi enviado com sucesso por qualquer m√©todo
            if sent_success:
                self.status_update.emit(f"‚úÖ Coment√°rio enviado com sucesso para '{username}'!")
                # Finalizar a a√ß√£o com sucesso
                self._finalizar_acao_com_sucesso(driver, username, acoes_realizadas, "comentar")
                return True # Sai da fun√ß√£o, sucesso!
            else:
                self.status_update.emit(f"‚ùå Coment√°rio n√£o verificado ap√≥s tentativas de envio.")
        except Exception as e_send_methods:
            self.status_update.emit(f"‚ùå Erro durante os m√©todos de envio (Enter/Bot√£o): {str(e_send_methods)}")
        # Se chegou aqui, a tentativa atual falhou (campo n√£o encontrado ou envio falhou)
        if tentativa < max_tentativas:
            self.status_update.emit(f"‚åõÔ∏è Aguardando antes da pr√≥xima tentativa ({tentativa + 1})...")
            time.sleep(3) # Aguarda antes da pr√≥xima tentativa
    # Se o loop de tentativas terminar sem sucesso
    self.status_update.emit(f"‚ùå Todas as {max_tentativas} tentativas de comentar falharam para '{username}'.")
    return False # Sai da fun√ß√£o, falha total

def _verificar_comentario_enviado(self, driver, texto_comentario):
    """Verifica se o coment√°rio foi realmente enviado."""
    try:
        # Aguardar um momento para o coment√°rio aparecer
        time.sleep(2)
        
        # Verificar 1: O campo de coment√°rio deve estar vazio
        try:
            campos_comentario = driver.find_elements(By.XPATH, "//textarea[contains(@placeholder, 'coment')]")
            for campo in campos_comentario:
                if campo.is_displayed() and campo.get_attribute("value") == "":
                    return True
        except:
            pass
        
        # Verificar 2: O coment√°rio deve aparecer na lista de coment√°rios
        try:
            comentarios = driver.find_elements(By.XPATH, "//ul/li/div[contains(@class, 'comment')]//span")
            for comentario in comentarios:
                if texto_comentario in comentario.text:
                    return True
        except:
            pass
        
        # Verificar 3: Verificar mensagem de "Coment√°rio publicado" ou similar
        try:
            mensagens = driver.find_elements(By.XPATH, "//*[contains(text(), 'Coment') or contains(text(), 'comment')]")
            for msg in mensagens:
                if "publicado" in msg.text.lower() or "posted" in msg.text.lower():
                    return True
        except:
            pass
        
        return False
    except Exception as e:
        self.status_update.emit(f"‚ö†Ô∏è Erro ao verificar coment√°rio: {str(e)}")
        return False

def _finalizar_acao_com_sucesso(self, driver, username, acoes_realizadas, tipo_acao):
    """Finaliza uma a√ß√£o de coment√°rio com sucesso e fecha o navegador imediatamente.
    
    Args:
        driver: WebDriver do Selenium
        username: Nome do perfil
        acoes_realizadas: Lista de a√ß√µes j√° realizadas
        tipo_acao: Tipo da a√ß√£o conclu√≠da
    
    Returns:
        bool: True se a a√ß√£o foi finalizada com sucesso, False caso contr√°rio
    """
    # Adicionar √† lista de a√ß√µes realizadas para este perfil
    acoes_realizadas.append(tipo_acao)
    
    # Fechar o navegador imediatamente
    try:
        driver.quit()
        self.status_update.emit(f"üö™ Navegador de '{username}' fechado ap√≥s coment√°rio bem-sucedido.")
    except Exception as e:
        self.status_update.emit(f"‚ö†Ô∏è Erro ao fechar navegador: {str(e)}")
    
    # Remover perfil dos workers ativos
    if username in self.workers_ativos:
        del self.workers_ativos[username]
    
    # Usar lock para garantir acesso thread-safe √† vari√°vel compartilhada
    with self.acoes_lock:
        self.acoes_concluidas += 1
        # Emitir sinal para atualizar a interface em tempo real
        self.progresso_atualizado.emit(self.acoes_concluidas, self.total_acoes)
        # Verificar se atingimos o n√∫mero total de a√ß√µes
        if self.acoes_concluidas >= self.total_acoes:
            self.status_update.emit(f"‚ú® Total de a√ß√µes conclu√≠das! ({self.acoes_concluidas}/{self.total_acoes})")
            self._stop_flag = True  # Para o bot quando atingir o total de a√ß√µes
    
    # Remover perfil da lista de perfis em execu√ß√£o
    if username in self.perfis_em_execucao:
        self.perfis_em_execucao.remove(username)
    
    # Notificar conclus√£o da a√ß√£o
    nome_amigavel = "coment√°rio"
    self.acao_concluida.emit(username, tipo_acao, True, f"{nome_amigavel.capitalize()} realizado com sucesso")
    self.status_update.emit(f"‚úÖ {nome_amigavel.capitalize()} realizado com perfil '{username}' (Total: {self.acoes_concluidas}/{self.total_acoes})")
    
    return True

def _atualizar_status_acao_concluida(self, driver, username, acoes_realizadas, tipo_acao):
    """M√©todo legado - agora apenas chama _finalizar_acao_com_sucesso."""
    return self._finalizar_acao_com_sucesso(driver, username, acoes_realizadas, tipo_acao)
