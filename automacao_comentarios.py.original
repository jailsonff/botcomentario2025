import time
import random
import os
import pyperclip
import threading
from PyQt5.QtCore import QThread, pyqtSignal
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException, StaleElementReferenceException
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains

class AutomacaoComentariosWorker(QThread):
    """
    Worker especializado para executar coment√°rios automatizados em posts do Instagram usando perfis do Dolphin Anty.
    """
    # Sinais: perfil, a√ß√£o, sucesso, mensagem
    acao_concluida = pyqtSignal(str, str, bool, str)
    progresso_atualizado = pyqtSignal(int, int)  # a√ß√µes conclu√≠das, total de a√ß√µes
    status_update = pyqtSignal(str)
    automacao_concluida = pyqtSignal()

    def __init__(self, dolphin_manager, post_url, perfis, total_acoes, perfis_simultaneos, 
                 tempo_entre_acoes, texto_comentario="", parent=None, manter_navegador_aberto=False):
        super().__init__(parent)
        self.dolphin_manager = dolphin_manager
        self.post_url = post_url
        self.perfis = perfis  # Lista de nomes de usu√°rio dos perfis
        self.total_acoes = total_acoes
        self.perfis_simultaneos = perfis_simultaneos
        self.tempo_entre_acoes = tempo_entre_acoes
        self.manter_navegador_aberto = manter_navegador_aberto
        
        # Tratar o texto_comentario como uma lista de coment√°rios
        if texto_comentario:
            # Dividir o texto em linhas e filtrar linhas vazias
            self.lista_comentarios = [linha.strip() for linha in texto_comentario.split('\n') if linha.strip()]
        else:
            self.lista_comentarios = []
        self._stop_flag = False
        self.acoes_concluidas = 0
        self.workers_ativos = {}  # Armazena os drivers ativos por perfil

    def stop(self):
        """Para a execu√ß√£o da automa√ß√£o."""
        self._stop_flag = True
        self.workers_ativos.clear()

    def run(self):
        """Executa a automa√ß√£o de coment√°rios nos perfis."""
        if not self.perfis or not self.post_url:
            self.status_update.emit("‚ùå Erro: URL do post ou lista de perfis vazia.")
            self.automacao_concluida.emit()
            return

        # Verifica se h√° coment√°rios dispon√≠veis
        if not self.lista_comentarios:
            self.status_update.emit("‚ùå Erro: Nenhum coment√°rio definido.")
            self.automacao_concluida.emit()
            return

        # Verifica se o n√∫mero de a√ß√µes √© maior que o n√∫mero de perfis dispon√≠veis
        if self.total_acoes > len(self.perfis):
            self.status_update.emit(f"‚ö†Ô∏è Aviso: O n√∫mero de a√ß√µes ({self.total_acoes}) √© maior que o n√∫mero de perfis dispon√≠veis ({len(self.perfis)}). Alguns perfis ser√£o usados mais de uma vez.")

        # Embaralha a lista de perfis para usar em ordem aleat√≥ria
        perfis_disponiveis = self.perfis.copy()
        random.shuffle(perfis_disponiveis)

        # Inicia o loop de automa√ß√£o
        self.acoes_concluidas = 0
        self.progresso_atualizado.emit(self.acoes_concluidas, self.total_acoes)
        
        # Criar um lock para acesso thread-safe √† vari√°vel acoes_concluidas
        self.acoes_lock = threading.Lock()
        
        # Criar uma lista para controlar os perfis j√° usados
        self.perfis_em_execucao = []
        
        while self.acoes_concluidas < self.total_acoes and not self._stop_flag:
            # Verifica quantos workers est√£o ativos no momento
            workers_ativos_count = len(self.workers_ativos)
            
            # Se j√° temos o m√°ximo de workers ativos, aguarda
            if workers_ativos_count >= self.perfis_simultaneos:
                time.sleep(1)
                continue
            
            # Verificar quantas a√ß√µes j√° foram iniciadas (em execu√ß√£o + conclu√≠das)
            with self.acoes_lock:
                acoes_em_andamento = len(self.perfis_em_execucao)
                acoes_totais_iniciadas = acoes_em_andamento + self.acoes_concluidas
                
                # Se j√° iniciamos todas as a√ß√µes necess√°rias, apenas aguarda a conclus√£o
                if acoes_totais_iniciadas >= self.total_acoes:
                    time.sleep(1)
                    continue
            
            # Selecionar pr√≥ximo perfil dispon√≠vel
            perfil_escolhido = None
            for perfil in perfis_disponiveis:
                if perfil not in self.perfis_em_execucao and perfil not in self.workers_ativos:
                    perfil_escolhido = perfil
                    break
            
            # Se n√£o encontrou perfil dispon√≠vel, tentar reutilizar um perfil
            if not perfil_escolhido and self.total_acoes > len(self.perfis):
                # Verificar quais perfis j√° foram usados mas n√£o est√£o ativos no momento
                perfis_ja_usados = [p for p in self.perfis if p not in self.perfis_em_execucao and p not in self.workers_ativos]
                if perfis_ja_usados:
                    perfil_escolhido = random.choice(perfis_ja_usados)
            
            # Se ainda n√£o encontrou perfil, aguardar
            if not perfil_escolhido:
                time.sleep(1)
                continue
            
            # Adicionar perfil √† lista de perfis em execu√ß√£o
            self.perfis_em_execucao.append(perfil_escolhido)
            
            # Iniciar thread para executar a a√ß√£o neste perfil
            self.status_update.emit(f"üöÄ Iniciando a√ß√£o com perfil '{perfil_escolhido}'")
            threading.Thread(target=self._executar_acao_perfil, args=(perfil_escolhido,)).start()
            
            # Aguardar intervalo entre a√ß√µes
            intervalo = random.uniform(self.tempo_entre_acoes * 0.8, self.tempo_entre_acoes * 1.2)  # Varia√ß√£o de ¬±20%
            self.status_update.emit(f"‚è±Ô∏è Aguardando {intervalo:.1f} segundos antes da pr√≥xima a√ß√£o...")
            time.sleep(intervalo)
        
        # Aguardar todos os workers conclu√≠rem
        while self.workers_ativos and not self._stop_flag:
            self.status_update.emit(f"‚åõ Aguardando {len(self.workers_ativos)} workers conclu√≠rem...")
            time.sleep(2)
        
        # Emitir sinal de conclus√£o
        self.status_update.emit(f"‚úÖ Automa√ß√£o conclu√≠da! {self.acoes_concluidas} coment√°rios realizados.")
        self.automacao_concluida.emit()

    def _executar_acao_perfil(self, username):
        """Executa a a√ß√£o para um perfil espec√≠fico."""
        if self._stop_flag:
            if username in self.perfis_em_execucao:
                self.perfis_em_execucao.remove(username)
            return
        
        # Tentar obter um coment√°rio aleat√≥rio
        if not self.lista_comentarios:
            self.status_update.emit(f"‚ùå Erro: Lista de coment√°rios vazia para '{username}'.")
            if username in self.perfis_em_execucao:
                self.perfis_em_execucao.remove(username)
            return
        
        comentario = random.choice(self.lista_comentarios)
        
        self.status_update.emit(f"üîÑ Iniciando navegador para '{username}'...")
        
        # Iniciar navegador e abrir post
        success, message = self.dolphin_manager.launch_profile_instagram(username, go_to_instagram_home=False)
        
        if not success:
            self.status_update.emit(f"‚ùå Erro ao abrir navegador para '{username}': {message}")
            if username in self.perfis_em_execucao:
                self.perfis_em_execucao.remove(username)
            return
        
        driver = self.dolphin_manager.get_profile_driver(username)
        if not driver:
            self.status_update.emit(f"‚ùå Erro: Driver n√£o encontrado para '{username}'.")
            if username in self.perfis_em_execucao:
                self.perfis_em_execucao.remove(username)
            return
        
        # Adicionar √† lista de workers ativos
        self.workers_ativos[username] = driver
        
        # Navegar para o post
        try:
            self.status_update.emit(f"üåê Navegando para URL do post ({username})...")
            driver.get(self.post_url)
            
            # Aguardar carregamento da p√°gina
            self._aguardar_carregamento_pagina(driver, username)
            
            # Aguardar um tempo para garantir que a p√°gina esteja totalmente carregada (crucial para m√∫ltiplos perfis)
            time.sleep(3)
            
            # IMPORTANTE: Para perfis m√∫ltiplos, precisamos dar foco para este navegador
            try:
                driver.execute_script("window.focus();")
                time.sleep(1)
                # Mover mouse para o centro da tela para ativa√ß√£o
                action = ActionChains(driver)
                action.move_by_offset(0, 0).click().perform()
                self.status_update.emit(f"üëÅÔ∏è Dando foco ao navegador de '{username}'...")
                time.sleep(0.5)
            except Exception as e:
                self.status_update.emit(f"‚ö†Ô∏è Erro ao ativar navegador: {str(e)}")
            
            # Verificar se est√° logado
            if not self.dolphin_manager.is_logged_in(driver):
                self.status_update.emit(f"üîë Perfil '{username}' n√£o est√° logado. Tentando login autom√°tico...")
                login_success, login_message = self.dolphin_manager.attempt_login_instagram(
                    driver, username, "sua_senha_aqui"
                )
                
                if not login_success:
                    self.status_update.emit(f"‚ùå Falha no login para '{username}': {login_message}")
                    driver.quit()
                    if username in self.workers_ativos:
                        del self.workers_ativos[username]
                    if username in self.perfis_em_execucao:
                        self.perfis_em_execucao.remove(username)
                    return
                
                # Ap√≥s login bem-sucedido, navegar novamente para o post
                driver.get(self.post_url)
                self._aguardar_carregamento_pagina(driver, username)
            
            # Lista para rastrear a√ß√µes realizadas
            acoes_realizadas = []
            
            # Realizar coment√°rio
            self.status_update.emit(f"üí¨ Tentando comentar com perfil '{username}'...")
            comentario_realizado = self._comentar_post(driver, username, comentario, acoes_realizadas)
            
            if not comentario_realizado:
                self.status_update.emit(f"‚ùå Falha ao comentar com perfil '{username}'.")
                driver.quit()
                if username in self.workers_ativos:
                    del self.workers_ativos[username]
                if username in self.perfis_em_execucao:
                    self.perfis_em_execucao.remove(username)
                return
            
        except Exception as e:
            self.status_update.emit(f"‚ùå Erro durante execu√ß√£o para '{username}': {str(e)}")
            driver.quit()
            if username in self.workers_ativos:
                del self.workers_ativos[username]
            if username in self.perfis_em_execucao:
                self.perfis_em_execucao.remove(username)
            return

    def _aguardar_carregamento_pagina(self, driver, username):
        """Aguarda o carregamento da p√°gina."""
        try:
            self.status_update.emit(f"‚è≥ Aguardando carregamento da p√°gina para '{username}'...")
            wait = WebDriverWait(driver, 30)
            wait.until(EC.presence_of_element_located((By.TAG_NAME, "article")))
            
            # Reduzido o tempo de espera ap√≥s carregar o artigo para agilizar o coment√°rio
            time.sleep(2)  # Tempo suficiente para garantir que podemos interagir com a p√°gina
            
            # Procurar explicitamente pelo campo de coment√°rio para garantir que est√° carregado
            seletores_campo_comentario = [
                "//form[contains(@class, 'comment')]//textarea",
                "//textarea[contains(@placeholder, 'coment')]",
                "//textarea[contains(@aria-label, 'comment')]",
                "//*[@role='textbox' and contains(@aria-label, 'coment')]",
                "//*[@placeholder='Adicione um coment√°rio...']",
                "//*[@placeholder='Add a comment‚Ä¶']"
            ]
            
            for seletor in seletores_campo_comentario:
                try:
                    wait.until(EC.presence_of_element_located((By.XPATH, seletor)))
                    self.status_update.emit(f"‚úÖ Campo de coment√°rio encontrado e pronto para '{username}'")
                    return  # Encontrou o campo, podemos continuar
                except:
                    continue
            
            # Se n√£o encontrou o campo, tentar rolar a p√°gina
            driver.execute_script("window.scrollTo(0, document.body.scrollHeight/2);")
            time.sleep(1)
        except Exception as e:
            self.status_update.emit(f"‚ö†Ô∏è Erro ao aguardar carregamento: {str(e)}")

    def _comentar_post(self, driver, username, texto_comentario, acoes_realizadas):
        """Tenta adicionar um coment√°rio ao post."""
        max_tentativas = 5  # Aumentado o n√∫mero de tentativas
        comentario_realizado = False
        
        # Apenas dar foco ao navegador antes de interagir, sem rolagem
        try:
            # IMPORTANTE: Dar foco ao navegador antes de interagir
            driver.execute_script("window.focus();")
            time.sleep(0.5)
        except Exception as e:
            self.status_update.emit(f"‚ö†Ô∏è Erro ao ativar navegador: {str(e)}")
            
        for tentativa in range(1, max_tentativas + 1):
            self.status_update.emit(f"üí¨ Tentativa {tentativa}/{max_tentativas} de comentar com '{username}'...")
            
            try:
                # Identificar o campo de coment√°rio com estrat√©gia mais agressiva
                seletores_campo_comentario = [
                    "//form[contains(@class, 'comment')]//textarea",
                    "//textarea[contains(@placeholder, 'coment')]",
                    "//textarea[contains(@aria-label, 'comment')]",
                    "//*[@role='textbox' and contains(@aria-label, 'coment')]",
                    "//*[@role='textbox']",  # Seletor mais gen√©rico
                    "//*[@placeholder='Adicione um coment√°rio...']",
                    "//*[@placeholder='Add a comment‚Ä¶']",
                    "//form//textarea",  # Qualquer textarea dentro de um form
                    "//section//textarea",  # Qualquer textarea dentro de section
                    "//textarea"  # √öltimo recurso: qualquer textarea na p√°gina
                ]
                
                campo_comentario = None
                
                # Esperar explicitamente pelo campo de coment√°rio
                try:
                    wait = WebDriverWait(driver, 10)
                    for seletor in seletores_campo_comentario:
                        try:
                            campo_comentario = wait.until(EC.element_to_be_clickable((By.XPATH, seletor)))
                            if campo_comentario.is_displayed():
                                self.status_update.emit(f"‚úÖ Campo de coment√°rio encontrado com seletor: {seletor}")
                                break
                        except:
                            continue
                except:
                    pass
                
                # Se ainda n√£o encontrou, tentar abordagem tradicional
                if not campo_comentario:
                    for seletor in seletores_campo_comentario:
                        try:
                            campo_comentario = driver.find_element(By.XPATH, seletor)
                            if campo_comentario.is_displayed():
                                self.status_update.emit(f"‚úÖ Campo de coment√°rio encontrado com seletor: {seletor}")
                                break
                        except:
                            continue
                
                # Se ainda n√£o encontrou, tentar rolagem em diferentes posi√ß√µes
                if not campo_comentario:
                    self.status_update.emit(f"‚ö†Ô∏è Campo de coment√°rio n√£o encontrado. Tentando rolagens diferentes...")
                    posicoes_rolagem = [100, 300, 500, 800, -100, -300]
                    
                    for posicao in posicoes_rolagem:
                        try:
                            driver.execute_script(f"window.scrollBy(0, {posicao});")
                            time.sleep(1)
                            
                            for seletor in seletores_campo_comentario:
                                try:
                                    campo_comentario = driver.find_element(By.XPATH, seletor)
                                    if campo_comentario.is_displayed():
                                        self.status_update.emit(f"‚úÖ Campo de coment√°rio encontrado ap√≥s rolagem {posicao}px: {seletor}")
                                        break
                                except:
                                    continue
                            
                            if campo_comentario and campo_comentario.is_displayed():
                                break
                        except:
                            continue
                
                if not campo_comentario:
                    self.status_update.emit(f"‚ùå Campo de coment√°rio n√£o encontrado em tentativa {tentativa}")
                    if tentativa < max_tentativas:
                        time.sleep(3)
                        continue
                    else:
                        return False
                
                # Estrat√©gia 1: Clique e digita√ß√£o direta com foco garantido
                try:
                    # IMPORTANTE: Para m√∫ltiplos perfis, precisamos garantir o foco no elemento
                    driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", campo_comentario)
                    time.sleep(0.5)
                    
                    # Usar JavaScript para destacar o campo vis√≠vel
                    driver.execute_script("""
                        arguments[0].style.border = '2px solid red'; 
                        arguments[0].style.backgroundColor = '#ffffcc';
                    """, campo_comentario)
                    time.sleep(0.5)
                    
                    # Limpar o campo usando JavaScript primeiro
                    driver.execute_script("arguments[0].value = '';", campo_comentario)
                    
                    # Clicar usando ActionChains para maior confiabilidade
                    actions = ActionChains(driver)
                    actions.move_to_element(campo_comentario).click().perform()
                    time.sleep(0.5)
                    
                    # Tentar digitar com diferentes m√©todos
                    campo_comentario.clear()
                    time.sleep(0.3)
                    
                    # M√©todo 1: Envio direto
                    campo_comentario.send_keys(texto_comentario)
                    time.sleep(0.5)
                    
                    # M√©todo 2: Digitar caractere por caractere
                    if not campo_comentario.get_attribute("value"):
                        for char in texto_comentario:
                            campo_comentario.send_keys(char)
                            time.sleep(0.05)
                    
                    time.sleep(0.5)
                    
                    # Tentar enviar coment√°rio
                    try:
                        # M√©todo 1: Pressionar Enter usando diferentes abordagens
                        # Primeiro, verificar se o texto foi inserido corretamente
                        campo_valor = campo_comentario.get_attribute("value")
                        self.status_update.emit(f"üí¨ Texto inserido: '{campo_valor}'")
                        
                        # M√©todo 1A: Pressionar Enter diretamente
                        campo_comentario.send_keys(Keys.ENTER)
                        time.sleep(1)
                        
                        # M√©todo 1B: Usar ActionChains para Enter
                        if not self._verificar_comentario_enviado(driver, texto_comentario):
                            actions = ActionChains(driver)
                            actions.move_to_element(campo_comentario).click().send_keys(Keys.ENTER).perform()
                            time.sleep(1)
                        
                        # M√©todo 1C: Usar JavaScript para submeter o formul√°rio
                        if not self._verificar_comentario_enviado(driver, texto_comentario):
                            try:
                                driver.execute_script("""
                                    var campo = arguments[0];
                                    var form = campo.form;
                                    if (form) form.submit();
                                """, campo_comentario)
                                time.sleep(1)
                            except:
                                pass
                            
                            # Verificar se o coment√°rio foi enviado
                            if self._verificar_comentario_enviado(driver, texto_comentario):
                                self.status_update.emit(f"‚úÖ Coment√°rio enviado com sucesso (m√©todo Enter)!")
                                # Finalizar a a√ß√£o com sucesso
                                self._finalizar_acao_com_sucesso(driver, username, acoes_realizadas, "comentar")
                                return True
                    except:
                        pass
                    
                    # M√©todo 2: Procurar bot√£o de enviar/publicar
                    try:
                        botoes_enviar = [
                            "//button[contains(@type, 'submit')]",
                            "//button[contains(text(), 'Publicar')]",
                            "//button[contains(text(), 'Post')]",
                            "//div[contains(text(), 'Publicar')]/parent::button",
                            "//div[contains(text(), 'Post')]/parent::button"
                        ]
                        
                        for seletor_botao in botoes_enviar:
                            try:
                                botao_publicar = driver.find_element(By.XPATH, seletor_botao)
                                if botao_publicar.is_displayed() and botao_publicar.is_enabled():
                                    botao_publicar.click()
                                    time.sleep(2)
                                    
                                    # Verificar se o coment√°rio foi enviado
                                    if self._verificar_comentario_enviado(driver, texto_comentario):
                                        self.status_update.emit(f"‚úÖ Coment√°rio enviado com sucesso (m√©todo bot√£o)!")
                                        # Finalizar a a√ß√£o com sucesso
                                        self._finalizar_acao_com_sucesso(driver, username, acoes_realizadas, "comentar")
                                        return True
                            except:
                                continue
                    except:
                        pass
{{ ... }}
                    ActionChains(driver).send_keys(Keys.ENTER).perform()
                    time.sleep(2)
                    
                    # Verificar se o coment√°rio foi enviado
                    if self._verificar_comentario_enviado(driver, texto_comentario):
                        self.status_update.emit(f"‚úÖ Coment√°rio enviado com sucesso (m√©todo Clipboard)!")
                        # Fechar o navegador imediatamente ap√≥s o coment√°rio ser enviado com sucesso
                        try:
                            driver.quit()
                            if username in self.workers_ativos:
                                del self.workers_ativos[username]
                            self.status_update.emit(f"üö™ Navegador de '{username}' fechado ap√≥s coment√°rio bem-sucedido.")
                        except Exception as e:
                            self.status_update.emit(f"‚ö†Ô∏è Erro ao fechar navegador: {str(e)}")
                        return self._atualizar_status_acao_concluida(driver, username, acoes_realizadas, "comentar")
                except:
                    pass
                
            except Exception as e:
{{ ... }}
            
            # Se n√£o conseguiu comentar, aguarda um pouco antes da pr√≥xima tentativa
            if not comentario_realizado:
                self.status_update.emit(f"‚åõÔ∏è Aguardando antes da pr√≥xima tentativa...")
                time.sleep(3)
        
        return False

    def _verificar_comentario_enviado(self, driver, texto_comentario):
        """Verifica se o coment√°rio foi realmente enviado."""
        try:
            # Aguardar um momento para o coment√°rio aparecer
            time.sleep(2)
            
            # Verificar 1: O campo de coment√°rio deve estar vazio
            try:
                campos_comentario = driver.find_elements(By.XPATH, "//textarea[contains(@placeholder, 'coment')]")
                for campo in campos_comentario:
                    if campo.is_displayed() and campo.get_attribute("value") == "":
                        return True
            except:
                pass
            
            # Verificar 2: O coment√°rio deve aparecer na lista de coment√°rios
            try:
                comentarios = driver.find_elements(By.XPATH, "//ul/li/div[contains(@class, 'comment')]//span")
                for comentario in comentarios:
                    if texto_comentario in comentario.text:
                        return True
            except:
                pass
            
            # Verificar 3: Verificar mensagem de "Coment√°rio publicado" ou similar
            try:
                mensagens = driver.find_elements(By.XPATH, "//*[contains(text(), 'Coment') or contains(text(), 'comment')]")
                for msg in mensagens:
                    if "publicado" in msg.text.lower() or "posted" in msg.text.lower():
                        return True
            except:
                pass
            
        except Exception as e:
            self.status_update.emit(f"‚ö†Ô∏è Erro ao fechar navegador: {str(e)}")
        return self._atualizar_status_acao_concluida(driver, username, acoes_realizadas, "comentar")
except:
    pass

def _verificar_comentario_enviado(self, driver, texto_comentario):
    """Verifica se o coment√°rio foi realmente enviado."""
    try:
        # Aguardar um momento para o coment√°rio aparecer
        time.sleep(2)
        
        # Verificar 1: O campo de coment√°rio deve estar vazio
        try:
            campos_comentario = driver.find_elements(By.XPATH, "//textarea[contains(@placeholder, 'coment')]")
            for campo in campos_comentario:
                if campo.is_displayed() and campo.get_attribute("value") == "":
                    return True
        except:
            pass
        
        # Verificar 2: O coment√°rio deve aparecer na lista de coment√°rios
        try:
            comentarios = driver.find_elements(By.XPATH, "//ul/li/div[contains(@class, 'comment')]//span")
            for comentario in comentarios:
                if texto_comentario in comentario.text:
                    return True
        except:
            pass
        
        # Verificar 3: Verificar mensagem de "Coment√°rio publicado" ou similar
        try:
            mensagens = driver.find_elements(By.XPATH, "//*[contains(text(), 'Coment') or contains(text(), 'comment')]")
            for msg in mensagens:
                if "publicado" in msg.text.lower() or "posted" in msg.text.lower():
                    return True
        except:
            pass
        
        return False
    except Exception as e:
        self.status_update.emit(f"‚ö†Ô∏è Erro ao verificar coment√°rio: {str(e)}")
        return False

def _finalizar_acao_com_sucesso(self, driver, username, acoes_realizadas, tipo_acao):
    """Finaliza uma a√ß√£o de coment√°rio com sucesso e fecha o navegador imediatamente.
    
    Args:
        driver: WebDriver do Selenium
        username: Nome do perfil
        acoes_realizadas: Lista de a√ß√µes j√° realizadas
        tipo_acao: Tipo da a√ß√£o conclu√≠da
    
    Returns:
        bool: True se a a√ß√£o foi finalizada com sucesso, False caso contr√°rio
    """
    # Adicionar √† lista de a√ß√µes realizadas para este perfil
    acoes_realizadas.append(tipo_acao)
    
    # Fechar o navegador imediatamente
    try:
        driver.quit()
        self.status_update.emit(f"üö™ Navegador de '{username}' fechado ap√≥s coment√°rio bem-sucedido.")
    except Exception as e:
        self.status_update.emit(f"‚ö†Ô∏è Erro ao fechar navegador: {str(e)}")
    
    # Remover perfil dos workers ativos
    if username in self.workers_ativos:
        del self.workers_ativos[username]
    
    # Usar lock para garantir acesso thread-safe √† vari√°vel compartilhada
    with self.acoes_lock:
        self.acoes_concluidas += 1
        # Emitir sinal para atualizar a interface em tempo real
        self.progresso_atualizado.emit(self.acoes_concluidas, self.total_acoes)
        # Verificar se atingimos o n√∫mero total de a√ß√µes
        if self.acoes_concluidas >= self.total_acoes:
            self.status_update.emit(f"‚ú® Total de a√ß√µes conclu√≠das! ({self.acoes_concluidas}/{self.total_acoes})")
            self._stop_flag = True  # Para o bot quando atingir o total de a√ß√µes
    
    # Remover perfil da lista de perfis em execu√ß√£o
    if username in self.perfis_em_execucao:
        self.perfis_em_execucao.remove(username)
    
    # Notificar conclus√£o da a√ß√£o
    nome_amigavel = "coment√°rio"
    self.acao_concluida.emit(username, tipo_acao, True, f"{nome_amigavel.capitalize()} realizado com sucesso")
    self.status_update.emit(f"‚úÖ {nome_amigavel.capitalize()} realizado com perfil '{username}' (Total: {self.acoes_concluidas}/{self.total_acoes})")
    
    return True

def _atualizar_status_acao_concluida(self, driver, username, acoes_realizadas, tipo_acao):
    """M√©todo legado - agora apenas chama _finalizar_acao_com_sucesso."""
    return self._finalizar_acao_com_sucesso(driver, username, acoes_realizadas, tipo_acao)
